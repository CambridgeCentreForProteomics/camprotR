% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/match_id.R
\name{match_id}
\alias{match_id}
\title{Match concatenated IDs in data.frame}
\usage{
match_id(data, to_match, ref, match, new, regex = "[^;]+", collapse = ";")
}
\arguments{
\item{data}{\code{data.frame}. Has the column to be matched.}

\item{to_match}{\code{variable}. Name of column in
\code{data} with the IDs to be matched.}

\item{ref}{\code{data.frame}. A reference data.frame with the IDs to use for
matching and the new columns to add to \code{data}.}

\item{match}{\code{string}. Name of column in \code{ref} to use for
matching.}

\item{new}{\verb{character vector}. Name of column(s) in \code{ref} to bind
to \code{data}. If not character columns, they will be coerced to class character
with a warning.}

\item{regex}{\code{string}. Regular expression to use for extracting the IDs
from the \code{to_match} column in \code{data}.}

\item{collapse}{\code{string}. If there are multiple IDs in the
\code{to_match} column, how should they be collapsed.}
}
\value{
Returns a transformed \code{data.frame} or \code{tibble} (depends on structure
of input data).
}
\description{
Match IDs in a data.frame to a reference table and then take other columns
from that reference table and bind them to the original data.frame. Mainly
used for matching metadata to UniProt accessions, but will work for any
type of string ID e.g. Ensembl IDs.
}
\examples{
ref_df <- data.frame(
  accession = c("AAA111", "BBB222", "CCC333", "DDD444"),
  name = c("protein a", "protein b", "protein c", "protein d"),
  value = c(11, 22, 33, 44)
)

my_df <- data.frame(
  uniprot.id = c("AAA111", "CCC333;BBB222", "EEE555"),
  r1 = c(1, 23, 5),
  r2 = c(1, 23, 5),
  r3 = c(1, 23, 5)
)

my_df2 <- match_id(
  my_df,
  uniprot.id,
  ref_df,
  "accession",
  c("name", "value")
)

}

---
title: "LFQ QC and summarisation to protein-level abundance"
author: "Tom Smith"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: camprotR.json
vignette: >
  %\VignetteIndexEntry{LFQ QC and summarisation to protein-level abundance}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r, message=FALSE, warning=FALSE}
library(UniProt.ws)
library(camprotR)
library(MSnbase)
library(naniar)
library(gplots)
library(biobroom)
library(ggplot2)
library(tidyr)
library(dplyr)
```

# Input data

We start by reading in a file containing peptide-level output from Proteome Discoverer (PD). This experiment was designed to identify RNA-binding proteins (RBP) in the U-2 OS cell line using the OOPS method [@http://zotero.org/users/5634351/items/EJHWF46N] with a comparison of RNase +/- used to separate RBPs from background non-specific proteins. 4 replicate experiments were performed, where the RNase +/- experiments were performed from the same OOPS interface. For each LFQ run, approximately the same quantity of protein was injected, based on quantification of peptide concentration post trypsin digestion. This data is not published but aim of the experiment is equivalent to Figure 2e in the original OOPS paper[@http://zotero.org/users/5634351/items/EJHWF46N].  

```{r}
pep_data <- lfq_oops_rnase
```

# Parse input data and remove contaminants 
The first step is to remove contaminant proteins. These were defined using the cRAP database. Below, we parse the cRAP fasta to extract the IDs for the cRAP proteins, in both 'cRAP' format and Uniprot IDs for these proteins.
```{r}
crap_fasta_inf <- system.file(
  "extdata", "cRAP_20190401.fasta.gz", 
  package = "camprotR"
)

# Load the cRAP FASTA used for the PD search
crap.fasta <- Biostrings::fasta.index(crap_fasta_inf, seqtype = "AA")

# Define a base R version of stringr::str_extract_all()
# base R str_extract
str_extract_all <- function(pattern, string) {
  gregexpr(pattern, string, perl = TRUE) %>% 
    regmatches(string, .) %>% 
    unlist()
}

# Extract the non cRAP UniProt accessions associated with each cRAP protein
crap.accessions <- crap.fasta %>% 
  pull(desc) %>% 
  str_extract_all("(?<=\\|).*?(?=\\|)", .) %>% 
  unlist()
```


We can then supply these cRAP protein IDs to `parse_features` which will remove features which may originate from contaminants, as well as features which don't have a unique master protein. 

Here, our output does not contain a protein accessions column, which is required by `parse_features` to perform complete removal of contaminants. We get around this here by specifying the protein column as the `Master.Protein.Accessions` but data should be exported from PD with the protein accessions. See `?parse_features` for further details, including the removal of 'associated cRAP' for conservative contaminants removal.

```{r}
pep_data_flt <- parse_features(
  pep_data, 
  crap_proteins = crap.accessions, 
  TMT = TRUE, 
  level = 'peptide',
  protein_col='Master.Protein.Accessions'
)
```
From the above, we can see that we have started with 7808 'features' (peptides) from 1463 master proteins across all samples. After removal of contaminants, peptides without quantification and peptides that can't be assigned to a unique master protein, we have 6539 peptides from 1194 master proteins.

We now store the filtered PSM data in an MSnSet, the standard data object for proteomics in R. See the MSnSet vignette for more details.
```{r}
# Abundance columns for TMT PD-output start with Abundance 
abundance_cols <- colnames(pep_data_flt)[grepl('Abundance.', colnames(pep_data_flt))]

pep.e <- as.matrix(pep_data_flt[, abundance_cols])
pep.f <- pep_data_flt[, setdiff(colnames(pep_data_flt), abundance_cols)]

# update the column names to remove the 'Abundance.` prefix and '.Sample' suffix
colnames(pep.e) <- gsub('(Abundance.|.Sample)', '', colnames(pep.e))

# Our first four samples (F17-F20) are RNase negative replicates 1-4 and F21-24 are
# RNase positive reps 1-4.
pep.p <- data.frame(row.names=colnames(pep.e),
                    'replicate'=rep(1:4, 2),
                    'condition'=rep(c('RNase_neg', 'RNase_pos'), each=4))

pep <- MSnbase::MSnSet(exprs = pep.e,
                       fData = pep.f,
                       pData = pep.p)

# Update the column names to a more human-understandable value
colnames(pep) <- paste(pep$condition,
                       pep$replicate,
                       sep='.')
```

# QC peptides
First of all, we want to inspect the peptide intensity distributions. We expect these to be approximately equal and any very low intensity sample would be a concern that would need to be further explored. Here, we can see that there is some clear variability, but no sample with very low intensity.

```{r, fig.height=3, fig.width=4, fig.fullwidth=TRUE, fig.cap="Peptide intensities"}
pep %>%
  log(base=2) %>%
  camprotR::plot_quant(method='density')
```

Next, we consider the missing values. Note that `MSnbase::plotNA` assumes the object contains protein-level data and names the x-axis accordingly. Here, we update the plot aesthetics and rename the x-axis


```{r, fig.show='hide'}
p <- MSnbase::plotNA(pep, pNA=0) +
  camprotR::theme_camprot(border=FALSE, base_family='sans', base_size=10) +
  xlab('Peptide index')
```
So, from the 6539 peptides, just 2089 have quantification values in all 8 samples. This is not a suprise for LFQ, since each sample is run separately.

```{r, fig.height=4, fig.width=5, fig.fullwidth=TRUE, fig.cap="Data completeness, all peptides"}
print(p)
```


We can explore the structure of the missing values further using an 'upset' plot.  

```{r, fig.height=5, fig.width=8, fig.fullwidth=TRUE, fig.cap="Missing values upset plot"}
missing_data <- pep %>%
  exprs %>%
  data.frame()

naniar::gg_miss_upset(missing_data,
                      sets=paste0(colnames(pep), '_NA'),
                      keep.order=TRUE,
                      nsets = 10)
```

So in this case, we can see that the most common missing value patterns are missing in just RNase negative replicate 4, or missing in all the other samples, except this sample. This sample also had slightly lower overall peptide intensities and appears to be somewhat of an outlier. In this case, we will retain the sample.

Finally, we can recode the abundances to binary (present/absent) and plot as a heatmap (missing = black). Beyond the aforementioned observations regarding RNase negative replicate 4, there's no clear structure in the missing values. This is what we would expect for LFQ, where data is typically missing at random (MAR). There are methods to impute values MAR, but, providing what we are after is protein-level abundance, it is usually more appropriate to perform the protein inference using a method that can accomodate missing values.
```{r, fig.height=4, fig.width=6, fig.fullwidth=TRUE, fig.cap="Presence/Absence heatmap"}
missing_data[!is.na(missing_data)] <- 1
missing_data[is.na(missing_data)] <- 0

gplots::heatmap.2(as.matrix(missing_data),
                  col = c("lightgray", "black"),
                  scale = "none", # Don't re-scale the input
                  # Default is euclidean, which is less appropriate distance for binary vectors
                  distfun = function(x) dist(x,method = 'binary'), 
                  trace = "none", # Don't include a trace. Improves appearance
                  key = FALSE, # Don't include a key as values are binary
                  Colv = F, # Don't re-order the columns
                  labRow=F, # Don't label the rows
                  cexCol=0.7 # Reduce the column name size
                  )
```
# Normalise
We have injected the same quantity of peptides for each sample, so it's reasonable to normalise the samples against one another. Here we will apply 'center-median' normalisation, which in `MSnbase::normalise` is called 'diff.median'. Since the peptide intensities are log-Gaussian distributed, we log(2)-transform them before performing the normalisation.
```{r, fig.height=3, fig.width=5, fig.fullwidth=TRUE, fig.cap="Protein intensities post-normalisation"}

pep_norm <- pep %>% log(base=2) %>% MSnbase::normalise('diff.median')  

pep_norm %>% plot_quant(method='density')

```

# Summarising to protein-level abundance
Before we can summarise to protein-level abundances, we need to exclude peptides with too many missing values. Here, peptides with more than 5/8 missing values are discarded, using `MSnbase::filterNA`. We also need to remove proteins without at least two peptides. We will use `camprotR::restrict_features_per_protein` which will replace quantification values with NA if the sample does not have two quantified peptides for a given protein. Note that this means we have to repeat the filtering process since we are adding missing values.

```{r}
pep_restricted <- pep_norm %>%
  MSnbase::filterNA(pNA=4/8) %>% # Maximum 4/8 missing values
  camprotR::restrict_features_per_protein(min_features=3, plot=FALSE) %>% # At least two peptides per protein
  # Repeat the filtering since restrict_features_per_protein will replace some values with NA
  MSnbase::filterNA(pNA=4/8) %>% 
  camprotR::restrict_features_per_protein(min_features=3, plot=FALSE) 

```

We can then re-inspect the missing values. Note that we have reduced the overall number of peptides to 4578
```{r, fig.show='hide'}
p <- MSnbase::plotNA(pep_restricted, pNA=0) +
  camprotR::theme_camprot(border=FALSE, base_family='sans', base_size=15) +
  xlab('Peptide index')
```
```{r, fig.width=6, fig.height=4, fig.fullwidth=TRUE, fig.cap="Data completeness, retained peptides"}
print(p)
```


We can now summarise to protein-level abundance. Below, we use 'robust' summarisation
[@http://zotero.org/users/5634351/items/FZN3QTTZ] with `MSnbase::combineFeatures`. This returns a warning about missing values that we can ignore here since the robust method is inherrantly designed to handle missing values.
```{r}
prot_robust <- pep_restricted %>%
  MSnbase::combineFeatures(
    # group the peptides by their master protein id
    groupBy=fData(pep_restricted)$Master.Protein.Accessions, 
    # See MsCoreUtils::robustSummary() and https://pubmed.ncbi.nlm.nih.gov/32321741/ for further details
    method='robust', 
    maxit=1000  # Ensures convergence for MASS::rlm
    ) 
```

We can then re-inspect the missing values at the protein level. So, we have quantification for 506 proteins, of which 289 are fully quantified across all 8 samples. The most common missing values pattern remains missing in just RNase negative replicate 4.
```{r, fig.show='hide'}
p <- MSnbase::plotNA(prot_robust, pNA=0) +
  camprotR::theme_camprot(border=FALSE, base_family='sans', base_size=15)
```


```{r, fig.width=6, fig.height=4, fig.fullwidth=TRUE}

print(p)
```

```{r, fig.width=8, fig.height=4, fig.fullwidth=TRUE}
naniar::gg_miss_upset(data.frame(exprs(prot_robust)),
                      sets=paste0(colnames(prot_robust), '_NA'),
                      keep.order=TRUE,
                      nsets = 10)


```


We have now obtained protein-level abundances from our LFQ data. This is our recommended procedure for summarising from peptide to protein level abundances. 

# Alternatives for summarising to protein-level abundance - MaxLFQ

Although we recommend using the 'robust' summarisation, there are other algorithms that are commonly applied. For example MaxLFQ[@http://zotero.org/users/5634351/items/87YIDK69], which is implemented within MaxQuant, but also available via the maxLFQ function in the iq package in R. 
```{r}



# You may wish to retain more feature columns that this! 
feature_coloumns_to_retain <- c("Master.Protein.Accessions")

# To ensure we are only comparing the protein inference method and not normalisation etc,
# we will use the same set of peptides for both inference methods
pep_data_for_summarisation <- pep_restricted %>%
  exprs() %>%
  data.frame() %>%
  merge(fData(pep_restricted)[,feature_coloumns_to_retain ,drop=FALSE], 
        by='row.names') %>%
  select(-Row.names)
```

Below, we use `iq::maxLFQ` manually, though it should be possible to use this function within `MSnbase::combineFeatures` too in theory since it accomodates user-defined functions.
```{r}
# At time of writing, iq was unavailable on CRAN (see https://github.com/tvpham/iq/issues/2)
# but can be installed from github like so
#devtools::install_github("tvpham/iq")

# Define a function to perform MaxLFQ on a single protein and return a data.frame
# as required. 
get_maxlfq_estimate <- function(obj){
  prot <- iq::maxLFQ(as.matrix(obj))$estimate
  data.frame(t(prot)) %>% setNames(colnames(obj))
}

# Group by the features we want to retain and use MaxLFQ on each protein
maxlfq_estimates <- pep_data_for_summarisation %>%
  group_by_at(feature_coloumns_to_retain) %>%
  dplyr::group_modify(~get_maxlfq_estimate(.)) %>%
  ungroup()

# Create the protein-level MSnSet
maxlfq.e <- as.matrix(select(maxlfq_estimates, -Master.Protein.Accessions))
maxlfq.f <- data.frame(select(maxlfq_estimates, Master.Protein.Accessions))
maxlfq.p <- pData(pep_restricted)

prot_maxlfq <- MSnSet(exprs=maxlfq.e,
                      fData=maxlfq.f,
                      pData=maxlfq.p)

# Update the rownames to be the protein IDs
rownames(prot_maxlfq) <- maxlfq_estimates$Master.Protein.Accessions
```

We can now compare the protein-level abundance estimates.
```{r, warning=FALSE, fig.height=3, fig.width=5, fig.fullwidth=TRUE, fig.cap="Comparison of protein inference methods"}
# Define a function to extract the protein abundances in long form and
# add a column annotating the method
get_long_form_prot_exp <- function(obj, method_name){
  tidy(obj) %>%
    mutate(method=method_name)
}

# Single object with protein inference from both methods 
compare_protein_abundances <- rbind(
  get_long_form_prot_exp(prot_maxlfq, 'MaxLFQ'),
  get_long_form_prot_exp(prot_robust, 'Robust'))


compare_protein_abundances %>%
  pivot_wider(names_from=method, values_from=value) %>% # pivot to wider form for plotting
  ggplot(aes(Robust, MaxLFQ)) +
  geom_point(alpha=0.25, size=0.5) +
  theme_camprot(border=FALSE, base_family='sans', base_size=15) +
  geom_abline(slope=1, colour=get_cat_palette(2)[2], linetype=2, size=1)
```

There is a very good overall correlation. Let's inspect a few proteins with the largest differences between the two approaches to see what's going on for the edge cases.

```{r}
# Identify proteins with largest difference between the protein summarisation methods
proteins_of_interest <- compare_protein_abundances %>%
  pivot_wider(names_from=method, values_from=value) %>%
  mutate(diff=MaxLFQ-Robust) %>%
  arrange(desc(abs(diff))) %>%
  pull(protein) %>%
  unique() %>%
  head(5)

```

Below we define a function to plot the peptide and protein abundances for the two methods for a single protein. We can ignore the details since it's the plots themselves we are interested in.
```{r}

plot_pep_and_protein <- function(protein_of_interest){
  
  to_plot_compare <- compare_protein_abundances %>% filter(protein==protein_of_interest)
  
  pep_restricted[fData(pep_restricted)$Master.Protein.Accession==protein_of_interest] %>%
    exprs() %>%
    data.frame() %>%
    tibble::rownames_to_column('id') %>%
    pivot_longer(cols=-id) %>%
    ggplot(aes(name, value)) +
    geom_line(aes(group=id), colour='grey', alpha=0.5) +
    geom_point(colour='grey', alpha=0.5) +
    theme_camprot(base_size=15, border=FALSE, base_family='sans') +
    geom_line(data=to_plot_compare,
              aes(sample.id, value, colour=method, group=method)) +
    geom_point(data=to_plot_compare,
              aes(sample.id, value, colour=method)) +
    scale_colour_manual(values=get_cat_palette(2), name='LFQ summarisation method') +
    theme(axis.text.x=element_text(angle=45, vjust=1, hjust=1)) +
    ggtitle(protein_of_interest) +
    xlab('') +
    ylab('Protein abundance (log2)')
}

```

Below we apply the above function to each of our proteins of interest.
```{r, warning=FALSE, fig.fullwidth=TRUE, fig.height=4, fig.width=7}
proteins_of_interest %>% lapply(plot_pep_and_protein)
```

Looking at these examples, we can see that MaxLFQ is often estimating slightly higher abundances but with a very similar profile across the samples is very similar, so the summarisation approach is unlikely to affect the downstream analysis. It's not clear which of the two approaches is more correct in the examples above, but the publication proposing the robust protein inference (ref https://pubmed.ncbi.nlm.nih.gov/32321741/) does indicate it gives more accurate fold-change estimates overall.


We have now processed our peptide-level LFQ abundances and obtained protein-level abundances, from which we can perform our downstream analyses.

# Alternative normalisation - Using reference proteins

Finally, we consider an alternative normalisation approach where we have a strong prior expectation about the abundance of a subset of proteins. Our data is from an RNase +/- OOPS experiment. Since OOPS is known to enrich glycoproteins at the interface, we can use these proteins as an internal set of 'housekeeping' proteins which we expect to have no difference in abundance between RNase +/-.

First, we need to calculate the RNase +/- ratios, since this is the value we want to normalise. In other applications, you may wish to normalise the abundance estimates for each sample, rather than the ratio between samples.
```{r}
ratios <- exprs(prot_robust[,pData(prot_robust)$condition=='RNase_neg']) - exprs(prot_robust[,pData(prot_robust)$condition=='RNase_pos'])

prot_ratios <- MSnSet(exprs=ratios,
                      fData=fData(prot_robust),
                      pData=(pData(prot_robust) %>% filter(condition=='RNase_neg')))
```


Next, we need annotations regarding which proteins are glycoproteins and GO-annotated RBPs. [Once a notebook has been added to cover GO annotations, reference to that here to avoid repeating explanations about why we want to expand the set of GO anntotations]

Get all GO terms for our proteins.
```{r, eval=FALSE}
up <- UniProt.ws::UniProt.ws(taxId=9606)

keys <- rownames(prot_robust)
columns <- c("GO")
kt <- "UNIPROTKB"
res <- UniProt.ws::select(up, keys, columns, kt)


go_long <- res %>% separate_rows('GO', sep='; ') %>%
  separate(GO, into=c('GO', 'GO_ID'), sep=' \\[GO:') %>%
  mutate(GO_ID=paste0('GO:', gsub(']', '', `GO_ID`)))

go_all <- get_ancestor_go(
  go_long,
  feature_col = "UNIPROTKB",
  go_col = "GO_ID",
  verbose = TRUE
)

go_rbp <- "GO:0003723"

rbps <- go_all %>% 
  filter(GO_ID == go_rbp) %>% 
  pull(UNIPROTKB)


```

Identify the glycoproteins.
```{r, eval=FALSE}
up <- UniProt.ws::UniProt.ws(taxId=9606)


keys <- rownames(prot_robust)
columns <- c("FEATURES")
kt <- "UNIPROTKB"
res <- UniProt.ws::select(up, keys, columns, kt)

glycoproteins <- res %>% 
  filter(grepl("Glycosylation", FEATURES)) %>%
  mutate(Glyco.features = FEATURES) %>%
  separate_rows(Glyco.features, sep = "; ") %>%
  filter(grepl("Glycosylation", Glyco.features)) %>%
  mutate(Glyco.features = gsub("\\(|\\)", "", Glyco.features)) %>%
  separate(Glyco.features, into = c(NA, "Glycosylation.count"), sep = " ") %>%
  dplyr::select(UNIPROTKB, Glycosylation.count)

```
 
Add feature columns describing the glycoprotein and GO-RBP status of the proteins.
```{r}
fData(prot_ratios) <- fData(prot_ratios) %>%
  mutate(glycoprotein=rownames(prot_ratios) %in% glycoproteins$UNIPROTKB) %>%
  mutate(GO_RBP=rownames(prot_ratios) %in% rbps) %>%
  mutate(glyco_rbp=interaction(glycoprotein, GO_RBP)) %>%
  mutate(glyco_rbp=factor(recode(glyco_rbp,
                                 'TRUE.TRUE'='GO:RBGP',
                                 'FALSE.TRUE'='GO:RBP',
                                 'TRUE.FALSE'='Glycoprotein',
                                 'FALSE.FALSE'='Other'),
                          levels=c('GO:RBP', 'GO:RBGP', 'Other', 'Glycoprotein')))
  
```

Below, we define a function to plot the ratios for each functional sub-type of proteins and summarise the number of GO-annotated RBPs that have a log2 RNase -/+ ratio < -1.
```{r}
plot_ratios <- function(obj){
 to_plot <- merge(exprs(obj),
      fData(obj)[,'glyco_rbp',drop=FALSE],
      by='row.names') %>%
  pivot_longer(cols=-c(Row.names, glyco_rbp), names_to='sample', values_to='ratio') %>%
  merge(pData(obj), by.x='sample', by.y='row.names') %>%
   filter(is.finite(ratio))
 
 to_plot %>%
   filter(glyco_rbp=='GO:RBP') %>%
   group_by(replicate, neg_ratio=ratio<(-1)) %>%
   tally() %>%
   pivot_wider(names_from=neg_ratio, values_from=n) %>%
   mutate(`TRUE`=replace_na(`TRUE`, 0)) %>%
   mutate(perc_negative=100*`TRUE`/(`TRUE`+`FALSE`)) %>%
   select(replicate, perc_negative) %>%
   print()
 
  p <- to_plot %>% ggplot(aes(replicate, ratio, group=interaction(glyco_rbp, replicate), colour=factor(glyco_rbp))) +
    geom_boxplot(position=position_dodge()) +
    theme_camprot(border=FALSE, base_family='sans') +
    scale_colour_manual(values=c(get_cat_palette(3), 'black'), name='') +
    geom_hline(yintercept=0, linetype=2, colour='grey') +
    xlab('Replicate') +
    ylab('RNase -/+ ratio') 
  
  print(p)
  
  invisible(to_plot)
}

```

How do the ratios look pre-normalisation...

```{r, fig.width=8}
plot_ratios(prot_ratios)
```

OK, so the glycoproteins are not centered at zero and many GO-annotated RBPs with negative log RNase -/+ ratios (2-13%).

Below, we perform the center median normalisation to the set of reference proteins (here, the glycoproteins). 
```{r}

glycoprotein_medians <- prot_ratios[fData(prot_ratios)$glyco_rbp=='Glycoprotein',] %>% camprotR::get_medians()

prot_ratios_norm <- camprotR::center_normalise_to_ref(prot_ratios,
                                                      glycoprotein_medians,
                                                      center_to_zero=TRUE, # We want to center the glycoproteins around zero
                                                      on_log_scale=TRUE # The quantifications are on a log scale (log2 ratios)
                                                      )


```

And plot the ratios post-normalisation.
```{r, fig.width=8}
plot_ratios(prot_ratios_norm)
```

Now, the median log2 RNase -/+ ratio for glycoproteins is zero for all replicates and we have far fewer GO-annotated RBPs with negative log RNase -/+ ratios (0-1%).

# Session info {.unnumbered}

```{r sessionInfo, echo=FALSE}
sessionInfo()
```
